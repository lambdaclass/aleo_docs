# Leo Learning Notes

## Installing Leo

**Building from crates.io**
```bash
cargo install leo-lang
```

**Build from Source Code**

```bash
git clone https://github.com/AleoHQ/leo
cd leo
cargo build --release
```
and then run the executable on target dir:
```bash
./target/release/leo
```

## Project Overview

To create a new project in Leo we've use the following command:

```bash
leo new <project-name>
```

This will generate the following structure of directories:

```bash 
<project-name>/
├── Leo.toml 
├── README.md 
├── inputs/ 
│ ├── <project-name>.in 
│ └── <project-name>.state 
└── src/    
  └── main.leo
```

The `main.leo` file is the entry point of the project. It should contain a `main` function that takes the inputs as parameters of the function and then return a new one.

The `<project-name>.in` provides information about the inputs of the program and `<project-name>.state` with the record state information (owner, value, commitment, etc.) This `.state` file is generated by the Leo runtime it provides the Leo programs with that kind of information.

The `Leo.toml` is the Leo manifest that configures our package, similar to `Cargo.toml` in Rust projects.

When we first create a project it generates an example code in `main.leo`:

```rust
function main(a: u32, b: u32) -> u32 {
    let c: u32 = a + b;
    return c
}
```

The main function arguments provide the inputs to the circuit. They're allocated private variables in the program's constraint system.

---
To run the example code we can use the following command:
```bash
leo run
```
Underneath, this command runs a few other commands to generate everything that the program needs to run correctly. It will generate a new directory named `output` containing a bunch of new files. 

This is the list of commands that `leo run` use each one producing a new file:

1. `leo build`

This command will compile the `main.leo` file to check the program syntax and produce the circuit of that code. Leo crates a checksum file at `outputs/<project-name>.sum` to avoid future compilations.

2. `leo setup`

This command generates a proving key at `outputs/<project-name>.lpk` and a verifying key at `outputs/<project-name>.lvk`.

3. `leo prove`

This command generates a proof at `outputs/<project-name>.proof` using the inputs at `inputs/<project-name>.in` and a proving key at `outputs/<project-name>.lpk`

4. `leo run`

Lastly run command itself verifies the proof at `outputs/<project-name>.proof` using the verifying key `outputs/<project-name>.lvk` and outputs the verifier result to console.

After all the running process, the returned value of the main function is stored in another file at `output/<project-name>.out`.It contains a `[register]` section with the register used by the program to store the result. This register was previous declared in `inputs/<project-name>.in`.

Use the `leo clean` command to delete the old checksum and delete all the data of previous runs.

## Example 

Let's create a new project using the `leo new` command
```bash
leo new square
```
In this example the idea is to prove that we know the square of a number. This is how the main function will look like:

`main.leo`
```rust
function main(a: u32, const b: u32) -> bool {
    return square(a, b);
}

function square(a: u32, const b: u32) -> bool {
    return a * a == b;
}
```

And this is how the inputs looks: 

`inputs/square.in`
```rust
[main]
a: u32 = 5;

[constants]
b: u32 = 25;

[registers]
is_square: bool = false;
```
The `[main]` section has the inputs of the main function, they have to match names and types. 
The `[constants]` has the constants inputs of the main function, they have to match names and types.

During runtime, we load an initial input state into a record and expect and output state after the record is run. A register stores intermediate record state during this runtime and we define them in the `[registers]` section.

We set a default value for the register `is_square` in this case `false`. This declaration indicates the register that will be used to store the record state (the output of the main function). In this case the result will be `true` because indeed $5^2 = 25$.

The return value of the main function will automatically be written to the output registers in `output/square.out`. So running the `leo run` command we get the following output:

`output/square.out`
```rust
[registers]
is_square: bool = true;
```

We can test the logic of our main function using the `@test` annotation and the `leo test` command

```rust
@test
function test_square() {
    let a: u32 = 5;
    const b: u32 = 25;
    
    let result = square(a, b);

    console.assert(result == true);
}
```
